---
layout: post
section-type: post
title: 论文阅读 Palette Load Balancing Locality Hints for Serverless（EuroSys 23）
category: Paper
tags: [ "cache", "faas" ]
---
在FaaS平台上运行数据密集型应用时，性能往往会下降，一个重要原因是缺乏计算贴近数据的功能。作者通过“颜色”的提示。 Palette在保持服务无服务器特性（用户无需手动分配资源）的同时，**能够让平台将相互关联的连续调用调度到同一个执行节点上运行，从而改善性能**。

# 背景

在许多应用程序如Web API前端服务和数据分析中，局部性是一个关键性能优化手段。例如，服务器常利用本地缓存并保持用户请求在同一服务器上处理，以最大化缓存利用率。而在数据分析中，任务链中前后任务间的数据复用也要求调度器尽量减少网络间的数据传输。

然而，在FaaS平台上运行这类应用时，**难以调度前后任务在同一实例上执行以利用数据局部性。**

# faas架构

图1描绘了一个标准无服务器FaaS系统的架构，主要包括一个前端入口和多个承载应用程序实例的工作者节点（这些实例运行在容器或虚拟机中）。当事件触发时，系统会自动调配合适的工作者实例来执行函数。

<!-- ![Untitled](/img/paper/palette/faasplatform.png) -->
<img src="/img/paper/palette/faasplatform.png" alt="sjss" width="750" height="500">

# 研究现状

目前，应用程序能够利用函数实例重用特性，将数据存储在简单的缓存中，例如全局变量或本地文件系统[8, 12]，这种方式对于那些获取成本高或计算代价大的只读数据十分有效。最近的研究对此特点做了进一步拓展，建立起了函数实例间的分布式缓存机制[ofc, faast]，甚至把遗留的函数实例转变为可供外部使用的低成本内存缓存[82]。

# 本地缓存的好处

Cloudburst [78]的研究人员报告称，对于从本地缓存汇总10个数组的操作，与从内存中的远程键值存储（KVS）读取相比，其延迟降低了2至9倍（取决于数据大小），图5所示。同样地，Faa$T缓存[70]的研究人员报告了三个基准测试中，从本地缓存读取数据时的端到端延迟比通过网络从远程缓存读取低1.3至近5倍[70]。

---

# 两种常见应用问题

在Web服务和API设计中，利用缓存是提升性能的常用手段，在FaaS场景下尤其如此。由于单个函数实例可以处理多个连续请求并保持临时数据，在处理数据库查询结果、社交网络信息等方面进行缓存可以加速响应时间并减轻后端系统的压力。然而，要确保相关请求能够被定向到同一函数实例以便利用缓存资源，传统的会话粘性策略可能不够有效，因为并行运行的众多函数实例可能导致来自同一用户的连续请求无法命中同一缓存。

为了演示局部性优化的效果，研究者在一个开源的Azure Functions宿主环境基础上构建了一个基于Dask Distributed调度器的无服务器版本。在这个实现中，DAG的每一个节点作为一次无服务器函数调用执行，中间计算结果存储在远程对象存储系统，并通过改进后的Faa$T无服务器缓存技术进行数据交换，以期提高缓存利用率及整体性能。

---

# 颜色参数

颜色参数在 FaaS 接口中的作用是通过指定一个不透明的提示，来增强对调用的局部性。调用的颜色会尽可能地将相同颜色的请求路由到同一个实例或一组实例上，以保持平台的无服务器特性，并实现关注点的强分离。用户可以根据他们对局部性和数据依赖关系的理解，通过着色策略来指定调用的颜色，而无需直接引用特定实例或工作者。另一方面，平台负责通过颜色调度策略将调用路由到实例上。重要的是，颜色是提示而不是硬约束，即使平台忽略了这个提示，应用程序仍应该正确运行。

![Untitled](/img/paper/palette/palettePlatform.png)

着色执行过程可以提高两个使用案例中的函数性能。

在第一个案例中，**图4a**展示了两个用户对共同好友帖子的请求。如果这两个请求使用post_id作为颜色，并在同一实例上执行，则第二个请求可能可以从本地缓存读取帖子内容，提高性能。

在第二个案例中，图4b展示了一个简单的DAG，其中节点代表任务，箭头表示数据依赖关系。如果有两个实例并行运行中间任务，按照图中所示对链中的任务进行着色可以最大限度地减少跨节点传输，提高执行效率。

![Untitled](/img/paper/palette/color.png)
<!-- <img src="/img/paper/palette/color.png" alt="sjss" width="20" height="10"> -->

---

# 三种颜色调度策略

我们在Palette中实现了三种颜色调度策略，分别是**一致性哈希、桶哈希和最少分配颜色**。这些策略的目标是将来自用户调用的颜色映射到应用程序的实例上，由负载均衡器维护这种映射。对于**哈希策略**，我们使用了一致性哈希来最小化无效映射。**桶哈希引入了间接映射**，将颜色哈希到一定数量的桶中，然后以改善负载平衡的方式将桶分配给实例。在我们的实现中，我们选择了与Redis相同的桶数量，即16,384。**最少分配（Least Assigned）策略**是一种颜色调度策略，其核心思想是维护一个显式的颜色到实例的映射表。当新颜色到来时，负载均衡器会选择分配颜色最少的实例，以打破可能的平局，并将映射存储在“LA”表中。

除了这三种策略外，我们还实现了**两种基准策略**进行比较：忽略局部性的策略总是为**每次调用选择一个随机实例**，而忽略局部性但**采用轮询方式发送请求给实例的策略**（oblivious round-robin），以改善实例间的负载均衡。

# 两种DAG着色方式

**链式着色**是一种用于并行执行有向无环图（DAG）的调度方法。它将DAG分成若干条简单路径（链），然后为每条路径分配一个独立的颜色。这样做的好处是可以确保同一路径上的节点具有相同的颜色，从而避免了节点之间的外部数据传输。此外，链式着色还尽可能地确保每个颜色表示的路径中的节点是可以并行执行的，以最大化并行性。虽然链式着色可以在一定程度上提高性能，但在网络传输成本较高的情况下，其性能可能会受到影响。

**虚拟工作者方法**是一种用于调度任务的策略，其中任务的着色是通过引入虚拟工作者来实现的。虚拟工作者不必映射到系统中的实际实例，而是可以为每个虚拟工作者分配一个颜色，并将其视为实际工作者。调度器可以根据虚拟工作者的颜色来做出调度决策，而实际上每个虚拟工作者都将其所有任务着色为自己的颜色。这种方法类似于用户级或绿色线程，它们在应用程序中看起来像线程，但实际上由操作系统映射到硬件线程。虚拟工作者方法的优势在于它能够利用框架已有的调度策略，同时提供了对任务着色的灵活性。

---

实验旨在**评估局部性提示对于本地缓存命中率的影响**。

1. **实验环境概述**：实验环境包括一个模拟的社交网络客户端和一个 MongoDB 后端数据库，它们部署在虚拟机上，并且可以扩展到最多 24 个函数工作节点虚拟机。实验的主要目标是评估在 Serverless 架构下，利用局部性提示对本地缓存整体命中率的影响。
2. **数据准备和工作负载模型**：首先，研究人员预加载了一个名为“socfb-Reed98”的真实社交网络数据集，其中包括用户关系图谱和每个用户的历史帖子数据。接下来，设计了一个模拟用户行为的工作负载模型，根据 Zipf 分布选择用户，并发出一系列 ReadHomeTimeline 和 ReadUserTimeline 请求，总共 72,000 次，其中两种请求类型各占一半。实验过程中，所有请求都基于同一固定的跟踪记录进行，以确保可比性，并且模拟场景为只读操作，以聚焦于本地缓存的局部性效应。
3. **实验结果**：在不考虑局部性的情况下，随着函数工作节点从 1 个增加到 24 个，本地缓存的命中率维持在一个较低水平，约为 4%。这是因为没有利用数据访问的局部性特征，导致相同或相近数据的请求分散到了不同的缓存实例中，从而造成了缓存利用率低下。相反，当引入局部性提示策略时，**缓存命中率显著提升到了 24% 以上**，显示出了明显的改善。这一结果与之前关于缓存分区能够有效提升缓存效率的研究结论相符，证明了在 Serverless 架构中采用局部性提示可以优化本地缓存性能，减少数据冗余存储，并提高整体系统的响应速度和资源利用率。

<!-- ![Untitled](/img/paper/palette/test.png) -->
<img src="/img/paper/palette/test.png" alt="sjss" width="500" height="400">


**无服务器缓存解决方案**

1. **Faa$T** 提供了为每个FaaS应用实例配置缓存的功能，使用一致性哈希实现缓存间的请求转发，但不影响FaaS调用路由。然而，这种方法在面对如Dask之类的复杂应用时，可能导致较多远程缓存命中的情况，性能与外部内存键值存储(KVS)相近。通过结合Palette的负载均衡器，我们在Dask和NumS中对无感知Faa$T进行了优化，使其性能提升了45%。
2. OFC 构建于OpenWhisk之上，实现了一种透明的、机会主义内存缓存机制，使用RAM-Cloud作为分布式缓存。OFC实现了基本的执行局部性，即将执行放在其输入所在的节点上执行。然而，这种策略仅在处理线性函数链时效果较好，对于具有大扇出结构（如TPC-H查询5、7、8、10和12）的查询，OFC会在同一节点调度所有输出节点，导致无法有效并行执行，从而降低性能。此外，OFC没有详述如何普遍实现局部性，因为它依赖于从调用中直接提取源对象。
3. Infinicache 创建了一个基于无服务器函数的分布式键值缓存系统，不论是无服务器应用还是非无服务器应用均可通过网络访问该缓存，并以低于传统键值缓存如Redis的成本实现。然而，Infinicache与Palette无关，也没有提及或提供关于局部性的具体功能支持。